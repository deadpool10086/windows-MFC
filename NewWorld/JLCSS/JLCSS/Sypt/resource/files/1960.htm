<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:none" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:none"><nobr>aabb1aabb</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:none" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle">&nbsp;&nbsp;&nbsp; 为了使Internet应用程序的开发更为方便，Windows同时提供了客户Internet API和服务器Internet API。应用程序利用这些API，无需掌握Gopher、FTP和HTTP协议的复杂细节知识，就可以提供和使用对应的服务。客户API包括Windows Internet和WinHTTP。Windows Internet也称为WinInet，它使得应用程序能够与Gopher、FTP和HTTP协议进行交互。WinInet支持Gopher、FTP和HTTP1.0及1.1协议。该API分别针对每个具体的协议被分解成一些子API集。应用程序使用与FTP相关的API，比如InternetConnect，与FTP服务器建立连接，使用FtpFindFirstFile和FtpFindNextFile可以列举一个FTP目录中的内容，使用FtpGetFile和FtpPutFile可以接收和发送文件。因此，应用程序的开发人员不需要了解有关FTP服务器建立连接的细节，也不再关心如何将TCP/IP消息格式转化成FTP协议。与Gopher相关的API以及与HTTP相关的API提供了类似的抽象层次，其中与HTTP相关的API提供了cookier持久性、自动拨号服务、客户端文件缓存以及自动凭证对话处理能力。<BR>&nbsp;&nbsp;&nbsp; WinInet API向用户提供了对现有Internet应用全面的支持，在提供专业性客户端程序支持方面，WinInet远远超过了Winsock。下面是一些WinInet的优点：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 缓冲机制<BR>&nbsp;&nbsp;&nbsp; 与Microsoft的Internet Explorer浏览器一样，WinInet客户端程序可以缓冲存储HTML文件和其它的Internet文件，而不需要做附加的工作。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 安全机制<BR>&nbsp;&nbsp;&nbsp; WinInet支持基本的身份认证，也支持Windows NT问讯/应答鉴定和SSL。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; Web代理访问<BR>&nbsp;&nbsp;&nbsp; WinInet支持代理服务器访问。当在控制面板输入代理服务器的信息，它被保存在系统注册表中。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 缓冲I/O<BR>&nbsp;&nbsp;&nbsp; WinInet的读函数会直到它读到了所请求的字节数后才返回，当然，如果服务器关闭了套接字，函数会立即返回。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 轻松简捷的API<BR>&nbsp;&nbsp;&nbsp; 在很多的情况下，WinInet只需要一个函数调用就可以找到服务器的IP地址，并打开连接，再做好读文件的准备；状态回调函数可以用于UI的更新和取消；有些函数甚至直接在Internet服务器与本地机的磁盘之间来拷贝文件。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 用户友好性<BR>&nbsp;&nbsp;&nbsp; WinInet分析和格式化头信息。如果一个服务器把一个文件移到了新的位置，它就会在HTTP Location头信息送回一个新的URL。WinInet可以很好的访问新的服务器，而且，WinInet在请求头中提供了文件的修改日期信息。然而就像利用其它的API的库函数进行编程一样，读者可能面对一大堆的API函数而无从下手。为了解决这个问题，Microsoft在它的MFC 4.2中提供了WinInet API的封装类，这就为广大的用户提供了一个更高层次上的编程接口。MFC对WinInet API函数按其应用类型进行分类打包，以面向对象的形式向用户提供了更加易用的高级编程接口。因此，利用MFCWinInet类来编写Internet应用程序是一种比较好的选择。<BR>&nbsp;&nbsp;&nbsp; 在使用WinInet API之前，先了解一下WinInet函数经常使用的一些基本概念。而在学习具体的用于FTP、HTTP和Gopher通信协议的WinInet API之前，再看一下WinInet函数如何处理错误代码以及缓冲区传送等问题。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 句柄<BR>&nbsp;&nbsp;&nbsp; 大多数的WinInet函数使用一种特殊的HINTERNET句柄，该句柄用于代表Internet对话、各个连接以及各种打开或查询调用的结果等内容。虽然这些句柄与其它Win32函数使用的文件句柄相似，但它们不能相互交换使用。<BR>&nbsp;&nbsp;&nbsp; HINTERNET句柄与其它Win32句柄之间的区别在于：Internet句柄被安排在一个树体系中。由InternetOpen()返回的对话句柄是该体系的主干，由InternetConnect()返回的连接句柄是该体系的分支。指向各个文件的句柄和查询结果构成该体系的树叶。根据句柄的具体类型，HINTERNET句柄可以有许多不同的选项与之相联系，这些选项可以通过InternetQueryOption()和InternetSetOption()来访问。它们可用来访问如下信息：句柄的具体类型、超时设置、返回、环境值、缓冲区大小以及其它设置。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 错误处理<BR>&nbsp;&nbsp;&nbsp; 组成WinInet API的函数与通常的Win32函数处理错误的方法不同。函数的返回值告诉调用是否成功。当发生错误时，函数返回FALSE或NULL；反之，函数返回一个有效的句柄。<BR>&nbsp;&nbsp;&nbsp; 在函数失败的事件中，可通过调用GetLastError()的方法，得到更多的具体的错误信息。如果GetLastError()返回ERROR_INTERNET_EXTERNDED_ERROR，有关用FTP或Gopher服务器的错误操作的更多信息可通过调用InternetGetLastResponseInfo()得到。对于HTTP操作，也可以使用InternetErrorDlg()函数来显示一个向用户解释错误的对话框，它允许用户对如何处理错误做出各种选择。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 缓冲区参数<BR>&nbsp;&nbsp;&nbsp; 许多WinInet API函数通过两个参数，指针和缓冲区长度返回一个长度可变的字符串。在传送的缓冲区大小不能容纳返回的字符串时，函数将失败，且GetLastError()将返回ERROR_INSUFFICIENT_ERROR。然而，缓冲区长度值将被修改以反映所需的缓冲区大小。可以使用这个值分配一段缓冲区并重新调用该函数。注意当调用成功完成时，缓冲区长度值不包含NULL终止符的内容。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 异步I/O<BR>&nbsp;&nbsp;&nbsp; WinInet API函数的默认操作是同步操作。当为每一个操作创建独立的线程时，这是很方便的。当然，在不希望为每次调用创建独立的线程时，处理异步完成的请求也是很有用的，特别是对于那些完成时间不确定的操作。为使用异步操作，可以调用InternetOpen()来设置INTERNET_FLAG_ASYNC标志。<BR>&nbsp;&nbsp;&nbsp; WinInet API是一个函数库，利用这些函数，用户可以编写面向Internet的应用程序，而不用考虑基本的通信协议。MFC提供的WinInet类是对WinInet API函数封装而来的，它为用户提供了更加方便的编程接口。</td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 