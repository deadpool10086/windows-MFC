<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:none" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:none"><nobr>aabb1aabb</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:none" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle"><P>&nbsp;&nbsp;&nbsp; 完成端口模型是目前最复杂的一种I/O模型。然而，假若一个应用程序同时需要管理为数众多的套接字，那么采用这种模型，往往可以达到最佳的系统性能。因其设计的复杂性，只有在应用程序需要同时管理数百乃至上千个套接字的时候，而且希望随着系统内安装的CPU数量的增多，应用程序的性能也可以线性提升，才应考虑采用完成端口模型<BR>&nbsp;&nbsp;&nbsp; 从本质上说完成端口模型要求我们创建一个Win32完成端口对象，通过指定一定数量的线程，对重叠I/O请求进行管理，以便为已经完成的重叠I/O构造机制，除套接字句柄外，实际上还可接受其他东西。使用这种模型之前，首先要创建一个I/O完成端口对象，用它面向任意数量的套接字句柄，管理多个I/O请求。要做到这一点，需要调用windows套接字函数CreateCompletionPort函数。该函数定义如下：</P>
<P align=center><IMG src="../upload/1228275053812_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 在我们深入讨论其中的各个参数之前，首先要注意该函数用途：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 创建一个完成端口对象。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 将一个句柄同完成端口关联到一起。<BR>&nbsp;&nbsp;&nbsp; 最开始创建一个完成端口时，唯一感兴趣的参数便是NumberOfConcurrentThreads（并发线程的数量）；前面3个参数都会被忽略。NumberOfConcurrentThreads参数的特殊之处在于，他定义了在一个完成端口上，同时允许执行的线程数量。理想情况下，我们希望每个处理器各自负责一个线程的运行，为完成端口提供服务，避免过于频繁的线程“场景”切换。若将该参数设为0，表明系统内安装了多个处理器，便允许同时运行多少个线程。可用下述代码创建一个I/O完成端口：</P>
<P align=center><IMG src="../upload/1228275081453_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 该语句的作用是返回一个句柄，在完成端口分配了一个套接字句柄后，用来对那个端口进行引用。<BR>&nbsp;&nbsp;&nbsp; 下面示例代码向大家阐述了如何使用完成端口模型，来开发一个回应服务器应用。在这个程序中，我们基本上按下述步骤行事：<BR>&nbsp;&nbsp;&nbsp; （1）创建一个完成端口。第四个参数保持为0，指定在完成端口上，每个处理器一次只允许执行一个工作者线程。<BR>&nbsp;&nbsp;&nbsp; （2）判断系统内到底装了多少个处理器。<BR>&nbsp;&nbsp;&nbsp; （3）创建工作者线程，根据第2) 步得到的处理器信息，在完成端口上，为已完成的I/O请求提供服务。在这个简单的例子中，我们为每个处理器都只创建一个工作者线程。这是用于事先已预计到，到时不会有任何线程进入“挂起”状态，造成由于线程数量不足，而使处理器空闲的局面（没有足够的线程可供执行）。调用CreateThread函数时，必须同时提供一个工作者例程，由线程在创建好执行。<BR>&nbsp;&nbsp;&nbsp; （4）准备好一个监听套接字，在端口5150上监听进入的连接请求。<BR>&nbsp;&nbsp;&nbsp; （5）使用accept函数，接受进入的连接请求。<BR>&nbsp;&nbsp;&nbsp; （6）创建一个数据结构，用于容纳“单句柄数据”，同时在结构中存入接受的套接字句柄。<BR>&nbsp;&nbsp;&nbsp; （7）调用CreateIoCompletionPort，将自accept返回的新套接字句柄同完成端口关联到一起。通过完成键参数，将单句柄数据结构传递给CreateIoCommpletionPort。<BR>&nbsp;&nbsp;&nbsp; （8）开始在已接受的连接上进行I/O操作。在此，我们希望通过重叠I/O机制，在新建的套接字上投递一个或多个异步WSARecv或WSASend请求。这些I/O请求完成后，一个工作者线程会为I/O请求提供服务，同时继续处理未来的I/O请求，稍后便会在第3）步指定的工作者例程中，体验到这一点。<BR>&nbsp;&nbsp;&nbsp; （9）重复第5）到第8）步，直至服务器终止。</P>
<P align=center><IMG src="../upload/1228275106937_pic.gif"></P></td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 