<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:none" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:none"><nobr>aabb1aabb</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:none" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle"><P>&nbsp;&nbsp;&nbsp; 不保留消息边界的协议通常称作“基于流的协议”。流服务的定义是连接的数据传输；不管消息边界是否存在，接收端都会尽量读取有效数据。对发送端来说，流服务允许系统将原始消息分解成小消息或把几条消息累积在一起，并形成一个较大的数据包。对接收端来说，数据一到达网络堆栈就开始读取它，并将它放在缓冲区中等候进程处理。在进程请求处理大量数据时，系统会尽量返回更多数据。但有一个前提，那就是不能溢出为客户端调用提供的缓冲区。在下图中，发送端提交了3个数据包：长度分别为128、64和32个字节，本地系统堆栈把这些数据聚合在一起，形成一个更大的数据包。这种情况下，重组后的两个数据包就会一起传输。是否将各个独立的数据包累积在一起，要由许多因素决定，例如最大传输单元或Nagle算法。在TCP/IP中，Nagle算法要求主机等待数据累计起来以后再将它们发到线上。这个主机一直等待下去，直到需要发送的数据累计到一定数量，或超过预定时间为止。实施Nagle算法时，主机的通信对方会在向主机发送确认之前，会使用一段预定的时间来等候要传出的数据，这样，主机的通信对方就不必发送一个只有确认消息的数据包。发送小数据包不仅没有多少意义，而且还会徒增错误检查和确认的开销。</P>
<P align=center><IMG src="../upload/1234943273218_pic.gif"></P>
<P align=center>图9&nbsp; 流服务</P>
<P>&nbsp;&nbsp;&nbsp; 在接收端，网络堆栈会针对给定进程把所有传入的数据聚集在一起。只要接收端一执行256字节缓冲区的recv调用，系统就会马上返回所有的224个字节。如果接收端只要求读取20个字节，则系统就只返回20个字节。</P></td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 