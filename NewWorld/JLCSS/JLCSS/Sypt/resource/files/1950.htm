<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:none" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:none"><nobr>aabb1aabb</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:none" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle"><P>&nbsp;&nbsp;&nbsp; 选择模型是Windows套接字和Berkeley套接字共有的模型。之所以称其为“选择模型”，是由于他的中心思想便是利用select函数，实现对I/O的管理。最初设计该模型时，主要面向的是某些使用UNIX操作系统的计算机，它们采用的是Berkeley套接字方案。select模型已集成到Windows套接字1.1中，它使那些想避免在套接字调用过程中被无辜“锁定”的应用程序，采取一种有序的方式，同时进行对多个套接字的管理。由于Windows套接字1.1向后兼容于Berkeley套接字实施方案，所以假如有一个Berkeley套接字应用使用了select函数，那么从理论角度讲，无需对其进行任何修改，便可正常运行。<BR>&nbsp;&nbsp;&nbsp; 利用select函数，我们判断套接字上是否存在数据，或者能否向一个套接字写入数据。之所以要设计这个函数，唯一的目的便是防止应用程序在套接字处于锁定模式中时，在一次I/O绑定调用（如send或recv）过程中，被迫进入“锁定”状态；同时防止在套接字处于非阻塞模式中时，产生WSAEWOULDBLOCK错误。除非满足事先用参数规定的条件，否则select函数会在进行I/O操作时锁定。select的函数原型如下：</P>
<P align=center><IMG src="../upload/1228273724453_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 其中，第一个参数nfds会被忽略。之所以仍然要提供这个参数，只是为了保持于早期的Berkeley套接字应用程序的兼容。大家可注意到三个fd_set参数：一个用于检查可读性（readfds），一个用于检查可写性（writefds），另一个用于例外数据（exceptfds）。从根本上说，fd_set数据类型代表着一系列特定套接字的集合。其中，readfds集合包括符合下述任何一个条件的套接字：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 有数据可以读入。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 连接已经关闭、重设或中止。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 假如已调用了listen，而且一个连接正在建立，那么accept函数调用会成功。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; writefds集合包括符合下述任何一个条件的套接字：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 有数据可以发出。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 如果已经完成了一个非阻塞连接调用的处理，连接就会成功。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 最后，exceptfds集合包括符合下述任何一个条件的套接字：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 假如已完成了对一个非阻塞连接调用的处理，连接尝试就会失败。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 有带外（Out-of-band,OOB）数据可供读取。<BR>&nbsp;&nbsp;&nbsp; 最后一个参数timeout对应的是一个空指针，它指向一个timeval结构，用于决定select最多等待I/O操作完成多久的时间。如timeout是一个空指针，那么select调用会无限期地“锁定”或停顿下去，直到至少有一个描述符符合指定的条件后结束，对timeval结构定义如下：</P>
<P align=center><IMG src="../upload/1228273735109_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 其中，tv_sec字段以秒为单位指定等待时间；tv_usec字段则以毫秒（ms）为单位指定等待时间。若将超时时间设置为（0，0），表明select会立即返回，允许应用程序对select操作进行“轮询”。处于对性能方面的考虑，应避免这样的设置。select成功完成后，会在fd_set结构中，返回刚好有未完成的I/O操作的所有套接字句柄的总量。若超过timeval设定的时间，便会返回0。不管由于什么原因，假如select调用失败，都会返回SOCEKT_ERROR。用select对套接字进行监视之前，在自己的应用程序中，必须将套接字句柄分配给一个集合，设置好一个或全部读、写以及例外fd_set结构。将一个套接字分配给任何一个集合后，再来调用select，便可知道一个套接字上是否正在发生上述的I/O活动。Windows套接字提供了下列宏操作，可用来对指针I/O活动，对fd_set进行处理与检查：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; FD_CLR(s, *set)：从set中删除套接字s。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; FD_ISSET(s, *set)：检查s是否set集合的一名成员：如果是，则返回TRUE。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; FD_SET(s, *set)：将套接字s加入集合set。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; FD_ZERO(*set)：将set初始化成空集合。<BR>&nbsp;&nbsp;&nbsp; 例如，假定我们想知道是否可从一个套接字中安全地读取数据，同时不会陷于无休止的“锁定”状态，便可使用FD_SET宏，将自己的套接字分配给fd_read集合，再来调用select。想要检测自己的套接字是否仍属于fd_read集合的一部分，可使用FD_ISSET宏。采用下述步骤，便可完成用select操作一个或多个套接字句柄的全过程：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 使用FD_ZERO宏，初始化自己感兴趣的每一个fd_set。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 使用FD_SET宏，将套接字句柄分配给自己感兴趣的每一个fd_set。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 调用select函数，然后等待在指定的fd_set集合中，I/O活动设置好一个或多个套接字句柄。select完成后，会返回在所有fd_set集合中设置的套接字句柄总数，并对每个集合进行相应的更新。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 根据select的返回值，我们应用程序便可判断出那些套接字存在着尚未完成的I/O操作――具体的方法是使用FD_ISSET宏，对每个fd_set及格进行检查。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 知道了每一个集合中“未完成”的I/O操作之后，对I/O进行处理，然后返回第1步，继续进行select处理。<BR>&nbsp;&nbsp;&nbsp; select返回后，他会修改每一个fd_set结构，删除那些不存在待决I/O操作的套接字句柄。这正是我们在上述的第4步中，为何要使用FD_ISSET宏来判断一个特定的套接字时候仍在集合中的原因。在下面程序中，我们向大家介绍一中（只有一种）套接字设置select模型所需的一系列基本步骤。若想在这个应用程序中添加更多的套接字，只需为额外的套接字维护它们的一个列表，或维护它们的一个数组即可。</P>
<P align=center><IMG src="../upload/1234157151515_pic.gif"></P></td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 