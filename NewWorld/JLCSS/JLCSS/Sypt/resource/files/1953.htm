<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:none" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:none"><nobr>aabb1aabb</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:none" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle"><P>&nbsp;&nbsp;&nbsp; 在Windows套接字中，与解释过的其他I/O模型相比，重叠I/O(Overlapped I/O)模型使应用程序能达到更佳的系统性能。重叠模型的基本设计原理便是让应用程序使用一个重叠的数据结构，一次投递一个或多个Windows套接字 I/O请求。针对那些提交的请求，他们完成之后，应用程序可以为他们提够服务。<BR>&nbsp;&nbsp;&nbsp; （1）事件通知<BR>&nbsp;&nbsp;&nbsp; 重叠I/O的事件通知方法要求将Win32事件对象与WSAOVERLAPPED关联在一起。若使用一个WSAOVERLAPPED结构，发出像WSASend和WSARecv这样的I/O调用，他们会立即返回。<BR>&nbsp;&nbsp;&nbsp; WSAOVERLAPPED结构在一个重叠I/O请求的初始化，及其后续的完成之间，提够了一种沟通或通信机制。下面是这个结构的定义：</P>
<P align=center><IMG src="../upload/1228274639953_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 其中，Internal、InternalHigh、Offset和OffsetHigh字段均由系统在内部使用，不应由应用程序直接进行处理或使用。而另一方面，hEvent字段有点特殊，它允许应用程序将一个事件对象句柄同一个套接字关联起来。<BR>&nbsp;&nbsp;&nbsp; 一个重叠I/O请求最终完成后，我们的应用程序要负责取回重叠I/O操作的结果。一个重叠请求操作最终完成之后，在事件通知方法中，Windows套接字会更改与一个WSAOVERLAPPED结构对应的一个事件对象的事件传信状态，将其从“未传信”变成“已传信”。由于一个事件对象已分配给WSAOVERLAPPED结构，所以只需要简单地调用WSAWaitForMultipleEvents函数，从而判断出一个重叠I/O调用在什么时候完成。发现一次重叠请求完成之后，接着需要调用windows套接字函数WSAGetOverlappedResult（取得重叠结构）函数，判断那个重叠调用到底是成功，还是失败。该函数的定义如下：</P>
<P align=center><IMG src="../upload/1228274650687_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 其中，s参数用于指定在重叠操作开始的时候，与之对应的那个套接字。lpOverlapped参数是一个指针，对应于在重叠操作开始时，指定的那个WSAOVERLAPPED结构。<BR>&nbsp;&nbsp;&nbsp; lpcbTransfer参数也是一个指针，对应一个DWORD（双字）变量，负责接收一次重叠发送或接收操作实际传输的字节数。fWait参数用于决定参数是否应该等待一次待决（未决）的重叠操作完成。若将fWait设为TRUE，那么除非操作完成，否则函数不会返回；若设为FALSE，而且操作仍然处于“待决”状态，那么WSAGetOverlappedResult函数会返回FALSE值，同时返回一个WSA_IO_INCMPLETE（I/O操作未完成）错误。但就我们目前的的情况来说，由于需要等候重叠操作的一个已传信事件完成，所以该参数无论采用什么设置，都没有任何效果。<BR>&nbsp;&nbsp;&nbsp; 最后一个参数是lpdwFlags，他对应于一个指针，指向一个DWORD（双字），负责接收结果标志（假如原先的重叠调用是用WSARecv或WSARecvFrom函数发出的）。<BR>&nbsp;&nbsp;&nbsp; 如WSAGetOverlappedResult函数调用成功，返回值就是TRUE。这意味着我们的重叠I/O操作已经成功完成，而且用lpcbTransfer参数指向的值已经进行了更新。若返回值是FLASE，那么可能是由下述任何一种原因造成的：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 重叠I/O操作仍处在“待决”状态。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 重叠操作已经完成，但含有错误。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 重叠操作的完成状态不可判决，因为在提供给WSAGetOverlappedResult函数的一个或多个参数中，存在着错误。<BR>&nbsp;&nbsp;&nbsp; 失败后，由lpcbTransfer参数指向的值不会进行更新，而且我们的应用程序应调用WSAGetLastError函数，调查到底是何种远造成了调用失败。<BR>&nbsp;&nbsp;&nbsp; 下面的示例程序中，使用Winsock2提供的异步I/O函数WSARecv。在调用WSARecv时，指定一个WSAOVERLAPPED结构，这个调用不是阻塞的，也就是说，它会立刻返回。一旦有数据到达的时候，被指定的WSAOVERLAPPED结构中的hEvent就会被通知。由于下面这个语句g_CliEventArr[ g_iTotalConn ] = g_pPerIODataArr[ g_iTotalConn ]-&gt;overlap.hEvent，使得与该套接字相关联的WSAEVENT对象也会被通知，所以WSAWaitForMultipleEvents的调用操作成功返回。我们现在应该做的就是用与调用WSARecv相同的WSAOVERLAPPED结构为参数调用WSAGetOverlappedResult，从而得到本次I/O传送的字节数等相关信息。在取得接收的数据后，把数据原封不动的发送到客户端，然后重新激活一个WSARecv异步操作。</P>
<P align=center><IMG src="../upload/1228274662968_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; （2）完成例程<BR>&nbsp;&nbsp;&nbsp; 完成例程是应用程序用来管理完成的重叠I/O请求的另一种方法。完成例程其实就是一些函数。起初，我们将其传递给一个重叠I/O请求，在一个重叠I/O请求完成时由系统调用。它们的基本设计宗旨是通过调用者的线程。为一个已经完成的I/O请求提供服务。除此之外，应用程序可以通过完成例程，继续进行重叠I/O处理。如果希望用完成例程为重叠I/O请求提供服务，在我们的应用程序中，必须为一个I/O定界Windows套接字函数，指定一个完成例程，同时指定一个WSAOVERLAPPED结构。一个完成例程必须拥有下述window套接字函数原型：</P>
<P align=center><IMG src="../upload/1228274681390_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 用完成例程完成了一个重叠I/O请求之后，参数中会包含下述信息：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 参数dwError表明了一个重叠操作（用lpOverlapped指定）的完成状态是什么。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; cbTransferred参数指定了重叠操作期间，实际传输的字节量是多大。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; lpOverlapped参数指定的是传递到最初的I/O调用内的一个WSAOVERLAPPED结构。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; dwFlags参数莫前未使用，应该为0。<BR>&nbsp;&nbsp;&nbsp; 用完成例程来实现重叠I/O比用事件通知简单得多。在下面示例程序中，主线程只用不停的接受连接即可；辅助线程判断有没有新的客户端连接被建立，如果有，就为那个客户端套接字激活一个异步的WSARecv操作，然后调用SleepEx使线程处于一种可警告的等待状态，以使得I/O完成后CompletionROUTINE可以被内核调用。如果辅助线程不调用SleepEx，则内核在完成一次I/O操作后，无法调用完成例程（因为完成例程的运行应该和当初激活WSARecv异步操作的代码在同一个线程之内）。<BR>&nbsp;&nbsp;&nbsp; 完成例程内的实现代码比较简单，它取出接收到的数据，然后将数据原封不动的发送给客户端，最后重新激活另一个WSARecv异步操作。注意，在这里用到了“尾随数据”。我们在调用WSARecv的时候，参数lpOverlapped实际上指向一个比它大得多的结构PER_IO_OPERATION_DATA，这个结构除了WSAOVERLAPPED以外，还被我们附加了缓冲区的结构信息，另外还包括客户端套接字等重要的信息。这样，在完成例程中通过参数lpOverlapped拿到的不仅仅是WSAOVERLAPPED结构，还有后边尾随的包含客户端套接字和接收数据缓冲区等重要信息。这样的C语言技巧在我后面介绍完成端口的时候还会使用到。</P>
<P align=center><IMG src="../upload/1228274694312_pic.gif"></P></td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 