<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:none" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:none"><nobr>aabb1aabb</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:none" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle"><P>&nbsp;&nbsp;&nbsp; Windows套接字的异步选择函数WSAAsyncSelect()提供了对网络事件基于消息机制的异步存取，通过该函数可以注册应用程序感兴趣的网络事件，当登记的网络事件发生时，相应的窗口将接收到一个消息，消息中保存了发生网络事件及其相关信息。<BR>&nbsp;&nbsp;&nbsp; 要想使用WSAAsyncSelect模型，在应用程序中，首先必须用CreateWindow函数创建一个窗口，再为该窗口提供一个窗口例程支持函数（Winproc）。亦可使用一个对话框，为其提供一个对话例程，而非窗口例程，因为对话框本质也是“窗口”。考虑到我们的目的，我们打算用一个简单的窗口来演示这种模型，采用的是一个支持窗口例程。设置好窗口的框架后，便可开始创建套接字，并调用WSAAsyncSelect函数，打开窗口消息通知。该函数的定义如下： </P>
<P align=center><IMG src="../upload/1228274192671_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 其中，s参数指定的是我们感兴趣的那个套接字。hWnd参数指定的是一个窗口句柄，它对应于网络事件发生之后，想要收到通知消息的那个窗口或对话框。wMsg参数指定在发生网络事件时，打算接收的消息。该消息会投递到由hWnd窗口句柄指定的那个窗口。通常，应用程序需要将这个消息设置比Windows的WM_USER大的一个值(WM_USER消息是Windows SDK提供的用户定义消息的起始值，任何一个用户定义消息号都必须大于WM_USER)，避免网络窗口消息与预定义的标准窗口消息发生混淆与冲突。最后一个参数是lEvnet，它指定的是一个位掩码，对应于一系列网络事件的组合，应用程序感兴趣的便是这一系列事件。大多数应用程序通常感兴趣的网络事件类型包括：FD_READ、FD_WRITE、FD_ACCEPT、FD_CONNECT和FD_CLOSE。当然，到底使用FD_ACCEPT还是使用FD_CONNECT类型，要取决与应用程序的身份到底是一个客户机，还是一个服务器。如应用程序同时对多个网络事件有兴趣，只需对各种类型执行一次简单的按位OR（或）运算，然后将它们分配给lEvent就可以了。举个例子来说：</P>
<P align=center><IMG src="../upload/1228274213640_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 这样一来，我们的应用程序以后便可在套接字socket上，接收到有关于连接、接收以及套接字关闭这一系列网络时间的通知。特别要注意的是，多个事件务必在套接字上一次注册。<BR>&nbsp;&nbsp;&nbsp; 另外还要注意的是，一旦在某个套接字上允许了事件通知，那么以后除非明确调用closesocket命令。或者由应用程序针对那个套接字调用了WSAAsyncSelect，更改了注册的网络事件类型，否则事件通知会永远有效。若将lEvent参数设为0，效果相当于停止套接字上进行所有网络事件通知。<BR>&nbsp;&nbsp;&nbsp; 若应用程序针对一个套接字调用了WSAAsyncSelect，那么套接字的模式会从“锁定”自动变成“非锁定”。这样一来，假如调用了像WSARecv这样的WinsockI/O函数，但当时却并没有数据可用，那么必然会造成调用的失败，并返回WSAEWOULDBLOCK错误。为防止这一点，应用程序应依赖于有WSAAsyncSelect的uMsg参数指定的用户自定义窗口消息，来判断网络事件类型何时在套接字上发生，而不应盲目地进行调用。<BR>&nbsp;&nbsp;&nbsp; 应用程序在一个套接字上成功调用了WSAAsyncSelect之后，应用程序会在与hWnd窗口句柄参数对应的窗口例程中，以Windows消息的形式，接收网络事件通知。窗口例程通常定义如下：</P>
<P align=center><IMG src="../upload/1228274229093_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 其中，hWnd参数指定一个窗口句柄，对窗口例程的调用正是由那个窗口发出的。uMsg参数指定需要对哪些消息进行处理。就我们的情况来说，感兴趣的是WSAAsyncSelect调用中定义的消息。wParam参数指定在其上面发生了一个网络事件的套接字。假若同时为这个窗口例程分配了多个套接字，这个参数的重要性便显示出来了。在lParam参数中，包含了两方面重要的信息。其中，lParam的低位字指定了已经发生的网络事件，而lParam的高位字包含了可能出现的任何错误代码。<BR>&nbsp;&nbsp;&nbsp; 网络事件消息抵达一个窗口例程后，应用程序首先检查lParam的高字位，以判断是否在套接字上发生了一个网络错误。这里有一个特殊的宏：WSAGETSELECTERROR，可用它返回高字位包含的错误信息。若应用程序发现套接字上没有产生任何错误，接着便应调查到底是哪个网络事件类型，造成了这条Windows消息的触发――具体的做法便是读取lParam的低字位的内容。此时可使用另一个特殊的宏：WSAGETSELECTEVENT，用它返回lParam的低字部分。<BR>&nbsp;&nbsp;&nbsp; 在下面的程序中，我们向大家演示了如何使用WSAAsyncSelect这种I/O模型，来实现窗口消息的管理。在源程序中，我们着重强调的是开发一个基本服务器应用要涉及到的基本步骤，忽略了开发一个完整的Windows应用需要涉及到的大量编程细节。</P>
<P align=center><IMG src="../upload/1228274239359_pic.gif"></P>
<P>&nbsp;&nbsp;&nbsp; 最后一个特别有价值的问题是应用程序如何对FD_WRITE事件同时进行处理。只有在3种条件下，才会发出FD_WRITE通知：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 使用connect或WSAConnect，一个套接字首次建立了连接。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 使用accept或WSAAccept，套接字被接收以后。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 若send、WSASend、sendto或WSASendTo操作失败，返回了WSAEWOULDBLOCK错误，而且缓冲区的空间变得可用。<BR>&nbsp;&nbsp;&nbsp; 因此，作为一个应用程序，自收到首条FD_WRITE消息开始，便应认为自己必然能在一个 上发出数据，直至一个send、WSASend、sendto或WSASendTo返回套接字错误WSAEWOULDBLOCK。经过了这样的失败以后，要再用另一条FD_WRITE通知应用程序再次发送数据。</P></td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 