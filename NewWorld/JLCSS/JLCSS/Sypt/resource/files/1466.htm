<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:"><nobr>内容摘要</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle">七. RIP的缺点及改进<BR>&nbsp;&nbsp;&nbsp; 1.&nbsp;&nbsp;RIP协议的缺点<BR>&nbsp;&nbsp;&nbsp; 2.&nbsp;&nbsp;RIP协议的改进<BR>八. RIP的限制</td>             </tr>           </table> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:"><nobr>相关内容</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle"><P><STRONG>七. RIP的缺点及改进</STRONG><BR><STRONG>1.&nbsp; RIP协议的缺点<BR></STRONG>&nbsp;&nbsp;&nbsp; （1）缓慢收敛<BR>&nbsp;&nbsp;&nbsp; 缓慢收敛是RIP的缺点之一，它是指在互联网上某处发生的变化要传播到互联网的其它部分是很慢的。例如，在下图中，网络1有了变化，路由器R1立即更新了自己的路由表。但是，由于每一个路由器每隔30秒才发送其定期更新，因此这表示这个变化要到达R2平均需要经过15秒（0到30秒之间）。R3要收到这个变化又要经过另一个平均15秒，等等。当这个信息最后到达路由器Rn时，已经经过了15×n秒。若n是20，则要经过300秒。在300秒内，ATM网络能够发送超过10亿位。若这样的变化影响这些位，则10亿位就丢失了。</P>
<P align=center><IMG src="../upload/1223625408343_pic.gif"></P>
<P align=center>图17-8&nbsp; 缓慢收敛</P>
<P>&nbsp;&nbsp;&nbsp; 解决RIP缓慢收敛的方法是限制跳数为15。这样可防止数据包无休止地在网络中兜圈子而阻塞了互联网。因此，数值16被认为是无穷大，并表示不可达的网络。如下图所示：</P>
<P align=center><IMG src="../upload/1223259038687_pic.gif"></P>
<P align=center>图17-9&nbsp; 跳数</P>
<P>&nbsp;&nbsp;&nbsp; （2）不稳定性<BR>&nbsp;&nbsp;&nbsp; RIP的另一个缺点是不稳定性，不稳定性表示运行RIP的互联网中数据包可能在一个回路中从一个路由器到另一个路由器兜圈子。把跳数限制为15能够改进稳定性，但不能解决所有的问题。<BR>&nbsp;&nbsp;&nbsp; 下图是一个不稳定性的例子，路由器A在它的路由表中对Net1写上的代价是0。路由器B只能通过路由器A才能接入到Net1，因此它的代价是1。现在假定Net1的连接断了，无法接入到Net1，这时路由器A立即响应，并把到Net1这列的代价改变为16（无穷大）。但是，它要等到30秒以后才能把这个新信息放在它的更新报文中发送出。在这时，路由器B可能把更新报文发送给A。路由器A现在有两列到Net1的项目：从它自己的路由表中得到的是代价为16，而从路由器B得到的代价是1。于是A被愚弄了，它想会有另一个路径可经过B再到Net1。路由器A就把他到Net1这列的代价改变为2（1＋1），并把这个更新发送给B。路由器B到Net1的代价现在是2（从A）和1（从它自己的路由表）。路由器B知道只有通过路由器A才能到达Net1，因此，它不考虑它自己的较低的代价而是把它代价改变为3（2＋1）。这样来回的更新不断继续下去，直到两个路由器都到达代价为16。到这个时候，这两个路由器才知道没有法子接入到网络Net1。</P>
<P align=center><IMG src="../upload/1223625416718_pic.gif"></P>
<P align=center>图17-10&nbsp; 不稳定性</P>
<P><STRONG>2.&nbsp; RIP协议的改进</STRONG><BR>&nbsp;&nbsp;&nbsp; （1）触发更新<BR>&nbsp;&nbsp;&nbsp; 触发更新可提高稳定性。若网络中没有变化，路由器按30秒的间隔发送更新信息。但若网络有变化，路由器就立即发送它的更新信息。这个过程叫做触发更新。<BR>&nbsp;&nbsp;&nbsp; 每一个路由器在收到有变化的更新信息时就立即发出新的信息，这比平均的15秒快了很多。虽然触发更新可大大地改进路由选择，但它不能解决所有的路由选择问题。例如，用这种方法不能处理路由器出故障的问题。<BR>&nbsp;&nbsp;&nbsp; （2）水平分割<BR>&nbsp;&nbsp;&nbsp; 水平分割也可以提高稳定性，在发送路由选择报文时增加了选择性，路由器必须区分不同的接口。如果路由器从某个接口已经收到了路由更新信息，那么这个同样的更新信息就不能再通过这个接口回送过去。如果某个接口通过了给某个路由器更新的信息，那么这个更新信息就不能再发送回去，这是已经知道了的信息，因而是不需要的。<BR>&nbsp;&nbsp;&nbsp; （3）毒性反转<BR>&nbsp;&nbsp;&nbsp; 路由中毒是指路由信息在路由表中失效时，先将度量值变为无穷大，而不是马上从路由表中删掉这条路由信息。<BR>&nbsp;&nbsp;&nbsp; 毒性反转与路由中毒概念是不一样的，它是指收到路由中毒消息的路由器，不遵守水平分割原则，而是将中毒消息转发给所有的相邻路由器，也包括发送中毒信息的源路由器，也就是通告相邻路由器这条路由信息己失效了。毒性反转的主要目的是加快收敛。<BR><STRONG>八. RIP的限制</STRONG><BR>&nbsp;&nbsp;&nbsp; 虽然RIP有很长的历史，但它还是有自身的限制。它非常适合于为早期的网络互联计算路由。然而，现代技术进步已极大地改变了互联网络建造和使用的方式。因此，RIP越来越不适应今天互联网的需求。<BR>&nbsp;&nbsp;&nbsp; RIP的一些限制是：<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 不能支持大于15跳的路径：RIP设计用于相对较小的自治系统。这样一来，它强制规定了一个严格的跳数限制为15跳。当报文由路由设备转发时，它们的跳数计数器会加上其要被转发的链路的耗费。如果跳数计值到15之后，报文仍没到达它寻址的目的地，那个目的地就被认为是不可达的，并且报文被丢弃。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 依赖于固定的度量来计算路由：对跳数的讨论为考察RIP的下一个基本限制作了很好的铺垫，这个限制就是固定耗费度量。虽然耗费度量能由管理员配置，但它们本质上是静态的。RIP不能实时地更新它们以适应网络中遇到的变化。由管理员定义的耗费度量保持不变，直到手动更新。这意味着RIP尤其不适合于高度动态的网络，在这种环境中，路由必须实时计算以反映网络条件的变化。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 路由更新耗费的资源过多：RIP节点会每隔30秒钟广播其路由表。在具有许多节点的大型网络中，这会消耗掉相当数量的带宽。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 相对缓慢的收敛：从人的角度来看，等待30秒进行一次更新不会感到不方便。然而，路由器和计算机以比人快得多的速度运行。不得不等上30秒进行一次更新会有很明显的不利结果。比仅仅等上30秒进行一次更新更具破坏性的是不得不等上180秒来作废一条路由。而这只是一台路由器开始进行收敛所需的时间。依赖于互联的路由器个数及它们的拓扑结构，可能需要重复更新才能完全收敛于新拓扑。RIP路由器收敛速度慢会创造许多机会使得无效路由仍被错误地作为有效路由进行广播。显然，这样会降低网络性能。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 缺乏动态负载均衡支持：由于RIP本身的特点，它缺乏对动态负载均衡的支持，如下图所示：</P>
<P align=center><IMG src="../upload/1223259056281_pic.gif"></P>
<P align=center>图17-11&nbsp; RIP缺乏动态负载均衡支持</P></td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 