<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:none" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:none"><nobr>aabb1aabb</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:none" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle">&nbsp;&nbsp;&nbsp; MAPI是Microsoft Windows Open Systems Architecture（WOSA）的一部分。MAPI提供了一种规范，在这些规范中，它详细说明了客户应用程序和信息服务程序之间如何通过普通的API调用实现交互操作。MAPI的实质就是将想要发送或接收消息的应用程序交给知道如何去发送或接收消息的应用程序（消息服务）的使用方法。<BR>&nbsp;&nbsp;&nbsp; MAPI的结构组件可以被分为两大类：客户应用程序和系统服务程序。客户应用程序是用来实现系统和客户之间的通信；系统服务程序则提供了内容广泛的服务，客户应用程序可以通过调用MAPI的函数来使用服务应用程序提供服务。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 客户应用程序<BR>&nbsp;&nbsp;&nbsp; 使用MAPI的客户应用程序可以分为三类：信报感知应用程序、信报传递应用程序和基于信报的应用程序。<BR>&nbsp;&nbsp;&nbsp; 信报感知应用程序通常用于执行基本的邮件操作，例如文字处理或图表处理工作，以及实现基本的信报功能，例如在应用程序之间通过E-mail传送文件等。<BR>&nbsp;&nbsp;&nbsp; 信报传递应用程序需要访问一个信报系统，完成各种不同的信报操作，如接收、发送等。<BR>&nbsp;&nbsp;&nbsp; 基于信报的应用程序需要访问更广泛的信报操作，包括确定邮件地址、邮件存储以及邮件传递等服务。这类应用程序无需客户参与基本信报系统操作。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; 服务提供程序<BR>&nbsp;&nbsp;&nbsp; 服务提供程序是用来提供一些基本的服务，客户应用程序则通过调用MAPI的函数来访问服务器所提供的基本服务。服务程序提供的服务主要有三种形式：信报存储服务、地址手册服务和传送服务，它们分别对应不同类型的应用程序。<BR>&nbsp;&nbsp;&nbsp; 信报存储服务提供程序相对来说就是信报库，它对各种不同信报采用了分层的结构存储，通常包括一些永久性的存储，如以磁盘文件形式等。信报存储服务提供程序为客户应用程序和其它的服务提供程序提供接口服务，通过这些接口，别的应用程序就可以访问存储的各种信报了。<BR>&nbsp;&nbsp;&nbsp; 地址手册服务提供程序包含了一个地址列表，用于发送信报的寻址。地址手册服务提供程序也负责提供其它应用程序访问地址手册中地址的接口。<BR>&nbsp;&nbsp;&nbsp; 传送服务提供程序负责系统间的信报传送。它应该做的工作包括使用合理的协议建立远程连接，以及以合理的方式发送或接收信报等。传送服务提供程序也负责从远程系统接收信报，并将接收的信报转换成本地信报的格式存储在一定的存储单元中。<BR>&nbsp;&nbsp;&nbsp; ●&nbsp; MAPI分类<BR>&nbsp;&nbsp;&nbsp; MAPI不是孤立的API，它是一个相互关联的系统。MAPI规范以各种形式给用户应用程序和服务提供程序提供接口，包括简单信报API，通用信报调用（CMC）API，扩展信报API和OLE信报。下面对各个不同的MAPI进行简单的介绍。<BR>&nbsp;&nbsp;&nbsp; 简单信报API包括一组用于处理消息的CAPI函数，它的函数允许用户的应用程序建立一个MAPI对话，发送和接收信报以及关闭MAPI对话。简单信报API多用于信报感知应用程序。<BR>&nbsp;&nbsp;&nbsp; 通用信报调用（CMC）API和简单信报API相似，但它们在功能上有差异。对于通用信报呼叫，CMC是一个执行X400 API Association（XAPIA）规范的工具，它们提供了一个处理信报的独立的API平台。由于CMC有更好的标准和可移植性，还有很多的新功能，因此对于新的应用程序，首先选择CMC，使用CMC很方便，因为它和简单信报MAPI的工作方式相同。<BR>&nbsp;&nbsp;&nbsp; 扩展MAPI与简单MAPI相比，提供了对信报系统组件更深层次的控制。扩展MAPI使用面向对象的方法对待接口。相对于CMC API，扩展MAPI是一个有全部特征的基于信报应用服务的API，而CMC API相对简单，是应用于信报通知和信报激活机制。在以信报为基础的应用程序中应该使用扩展MAPI，因为这种应用程序需要更直接地与信报存储、地址手册以及传送服务提供程序进行交互操作。<BR>&nbsp;&nbsp;&nbsp; 而OLE信报适用于更高级地应用程序开发环境，它向应用程序提供了比简单MAPI多的功能，但却不具有扩展MAPI的所有功能。</td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 