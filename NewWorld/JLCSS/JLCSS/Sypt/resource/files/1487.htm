<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:"><nobr>内容摘要</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle">二. OSPF协议简介<BR>三. 区域与度量<BR>&nbsp;&nbsp;&nbsp; 1.&nbsp; 区域<BR>&nbsp;&nbsp;&nbsp; 2.&nbsp; 度量<BR>四. 链路的类型<BR>&nbsp;&nbsp;&nbsp; 1.&nbsp; 链路的类型<BR>&nbsp;&nbsp;&nbsp; 2.&nbsp; 点对点链路<BR>&nbsp;&nbsp;&nbsp; 3.&nbsp; 转接链路<BR>&nbsp;&nbsp;&nbsp; 4.&nbsp; 残桩链路<BR>&nbsp;&nbsp;&nbsp; 5.&nbsp; 虚拟链路</td>             </tr>           </table> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:"><nobr>相关内容</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle"><P><STRONG>二. OSPF协议简介</STRONG><BR>&nbsp;&nbsp;&nbsp; OSPF（开放式最短路径优先）是一种典型的链路状态路由协议。采用OSPF的路由器彼此交换并保存整个网络的链路信息，从而掌握全网的拓扑结构，独立计算路由。该路由协议基于链路状态算法，具有收敛速度快，平稳，杜绝环路等优点，十分适合大型的计算机网络使用。目前广泛使用的是OSPF第二版。<BR>&nbsp;&nbsp;&nbsp; OSPF作为一种内部网关协议，用于在同一个自治系统中的路由器之间发布路由信息。在目前应用的路由协议中占有相当重要的地位。<BR><STRONG>三. 区域与度量</STRONG><BR><STRONG>1.&nbsp; 区域</STRONG><BR>&nbsp;&nbsp;&nbsp; 为了使路由选择高效，OSPF把一个自治系统划分为若干区域。一个区域包含一些网络、主机和路由器。一个自治系统可划分为若干个不同的区域。在一个区域里的所有网络必须是互相连接的。<BR>&nbsp;&nbsp;&nbsp; 在一个区域内的路由器使用洪泛法传送路由选择信息。区域之间使用区域边界路由器连接，区域边界路由器把有关本区域的信息汇总起来发送到其它区域。在自治系统中有一个特殊区域叫做主干；在自治系统中的所有区域必须连接到主干上。换言之，主干相当于一级区域，而其它的区域相当于二级区域，二级区域必须与一级区域相连。但这并不表示在各区域内的路由器不能互相连接。在主干中的路由器叫做主干路由器。主干路由器也可以同时是区域边界路由器。<BR>&nbsp;&nbsp;&nbsp; 如果在主干和区域之间的连通性被破坏了，则管理员必须创建路由器间的虚链路，以使得作为一级区域的主干的各种功能的连续性。<BR>&nbsp;&nbsp;&nbsp; 每一个区域有区域标识。主干的区域标识是零。下图给出了自治系统及其划分的区域。</P>
<P align=center><IMG src="../upload/1239697063578_pic.gif"></P>
<P align=center>图18-3&nbsp; 自治系统中的区域</P>
<P><STRONG>2.&nbsp; 度量</STRONG><BR>&nbsp;&nbsp;&nbsp; OSPF协议允许管理员给每一条路由指派度量。度量是基于区分服务的。一个路由器可以有多个路由表，而每一个路由表基于不同的区分服务。<BR><STRONG>四. 链路的类型<BR>1.&nbsp; 链路的类型</STRONG><BR>&nbsp;&nbsp;&nbsp; 在OSPF中已定义了4种类型的链路：点对点链路、转接链路、残桩链路和虚拟链路，如下图所示：</P>
<P align=center><IMG src="../upload/1223259533640_pic.gif"></P>
<P align=center>图18-4&nbsp; 链路的类型</P>
<P><STRONG>2.&nbsp; 点对点链路</STRONG><BR>&nbsp;&nbsp;&nbsp; 点对点链路连接两个路由器，而中间没有任何其它的主机或路由器。这种链路的目的仅仅是为了连接这两个路由器。比如两个路由器用一条电话线或一条双绞线连接起来。不需要给这种类型的链路指派一个网络地址。用图表示时，路由器用节点表示，而链路用一条连接两个节点的双向边来表示。度量则表示在两端，各表示每一个方向的度量，通常它们是一样的。每一个路由器在链路的另一端只有一个相邻主机，如下图所示：</P>
<P align=center><IMG src="../upload/1223259558187_pic.gif"></P>
<P align=center>图18-5&nbsp; 点对点链路</P>
<P><STRONG>3.&nbsp; 转接链路</STRONG><BR>&nbsp;&nbsp;&nbsp; 转接链路是一种网络，在它上面连接有若干个路由器。数据可以从任何一个路由器进入网络，并从任何一个路由器离开网络。所有具有两个或更多的路由器的局域网和广域网都属于这种类型。每一个路由器有几个相邻主机。如下图（A）所示的以太网，路由器B的相邻主机是A、C、D和E。可以用下图（B）的表示方法表示这种相邻主机关系。<BR>&nbsp;&nbsp;&nbsp; 这种关系既低效又不现实。说它低效是因为每一个路由器需要通知相邻的其它4个路由器，总共有20个通知。说它不现实是因为在每一对路由器之间没有一个单独的网络，只有一个网络用作所有这5个路由器之间的交叉路口。<BR>&nbsp;&nbsp;&nbsp; 为了表示每一个路由器是通过单个网络连接到其它的路由器的，将这个网络用一个节点来表示。网络并不是一台计算机，它不能像路由器那样工作，所以在网络中的一个路由器就担负起这个责任。这个路由器有双重作用：即是一个真路由器，又是一个指定路由器。如下图（C）的拓扑表示转接网络的连接：</P>
<P align=center><IMG src="../upload/1223259568953_pic.gif"></P>
<P align=center>图18-6&nbsp; 转接链路</P>
<P>&nbsp;&nbsp;&nbsp; 现在每一个路由器只有一个相邻主机，即指定路由器（网络）。另一方面，这个指定路由器有5个相邻主机。向相邻主机的通知数从20减少到10。另外，链路用连接节点的双向边来表示。虽然从每一个节点到指定路由器都有一个度量，但从指定路由器到任何其它节点都没有度量。原因就是指定路由器代表网络，不能为它计算两次。当数据包进入网络时，就指派一个代价，当数据包离开网络到其它的路由器时就没有代价。<BR><STRONG>4.&nbsp; 残桩链路</STRONG><BR>&nbsp;&nbsp;&nbsp; 残桩链路是指只连接到某个路由器的网络。数据包通过这个单一路由器进入网络，而离开网络也是通过这个路由器。这是转接网络的一个特例。这里将路由器表示为一个节点而用指定路由器表示这个网络。这条链路是单向的，即从路由器到网络，如下图所示：</P>
<P align=center><IMG src="../upload/1223259578593_pic.gif"></P>
<P align=center>图18-7&nbsp; 残桩链路</P>
<P><STRONG>5.&nbsp; 虚拟链路</STRONG><BR>&nbsp;&nbsp;&nbsp; 当两个路由器之间的链路断开时，管理员就在它们之间创建一条使用更长路径的虚拟链路，这可能要经过好几个路由器。</P></td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 