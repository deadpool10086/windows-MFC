<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:"><nobr>内容摘要</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle">六. OSPF运行过程<BR>&nbsp;&nbsp;&nbsp; 1.&nbsp; 建立路由器的邻接关系<BR>&nbsp;&nbsp;&nbsp; 2.&nbsp; 选举DR/BDR<BR>&nbsp;&nbsp;&nbsp; 3.&nbsp; 发现路由器<BR>&nbsp;&nbsp;&nbsp; 4.&nbsp; 选择适当的路由器<BR>&nbsp;&nbsp;&nbsp; 5.&nbsp; 维护路由信息<BR>七. OSPF链路状态公告类型</td>             </tr>           </table> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:"><nobr>相关内容</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle"><STRONG>六. OSPF运行过程</STRONG><BR><STRONG>1.&nbsp; 建立路由器的邻接关系</STRONG><BR>&nbsp;&nbsp;&nbsp; 所谓“邻接关系”是指OSPF路由器以交换路由信息为目的，在所选择的相邻路由器之间建立的一种关系。路由器首先发送拥有自身ID信息的Hello报文。与之相邻的路由器如果收到这个Hello报文，就将这个报文内的ID信息加入到自己的Hello报文内。如果路由器的某端口收到从其它路由器发送的含有自身ID信息的Hello报文，则它根据该端口所在网络类型确定是否可以建立邻接关系。<BR>&nbsp;&nbsp;&nbsp; 在点对点网络中，路由器将直接和对端路由器建立起邻接关系，并且该路由器将直接进入到第三步操作：发现其它路由器。若为MultiAccess网络，该路由器将进入选举步骤。<BR><STRONG>2.&nbsp; 选举DR/BDR</STRONG><BR>&nbsp;&nbsp;&nbsp; 不同类型的网络选举DR（指定路由器）和BDR（次级指定路由器）的方式不同。MultiAccess网络支持多个路由器，在这种状况下，OSPF需要建立起作为链路状态和LSA更新的中心节点。选举利用Hello报文内的ID和优先权（Priority）字段值来确定。优先权字段的取值范围是0到255，优先权值最高的路由器成为DR。如果优先权值大小一样，则ID值最高的路由器选举为DR，优先权值次高的路由器选举为BDR。优先权值和ID值都可以直接设置。<BR><STRONG>3.&nbsp; 发现路由器</STRONG><BR>&nbsp;&nbsp;&nbsp; 在这个步骤中，路由器与路由器之间首先利用Hello报文的ID信息确认主从关系，然后主从路由器相互交换部分链路状态信息。每个路由器对信息进行分析比较，如果收到的信息有新的内容，路由器将要求对方发送完整的链路状态信息。这个状态完成后，路由器之间建立完全相邻（Full Adjacency）关系，同时邻接路由器拥有自己独立的、完整的链路状态数据库。<BR><STRONG>4.&nbsp; 选择适当的路由器<BR></STRONG>&nbsp;&nbsp;&nbsp; 当一个路由器拥有完整独立的链路状态数据库后，它将采用SPF算法计算并创建路由表。OSPF路由器依据链路状态数据库的内容，独立地用SPF算法计算出到每一个目的网络的路径，并将路径存入路由表中。<BR>&nbsp;&nbsp;&nbsp; OSPF利用度量计算目的路径，度量最小者即为最短路径。在配置OSPF路由器时可根据实际情况，如链路带宽、时延或经济上的费用设置链路度量大小。度量越小，则该链路被选为路由的可能性越大。<BR><STRONG>5.&nbsp; 维护路由信息(
<OBJECT codeBase=http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=7,0,19,0 classid=clsid:D27CDB6E-AE6D-11cf-96B8-444553540000><PARAM NAME="_cx" VALUE="5080"><PARAM NAME="_cy" VALUE="5080"><PARAM NAME="FlashVars" VALUE=""><PARAM NAME="Movie" VALUE="../upload/1238378097640_swf.swf"><PARAM NAME="Src" VALUE="../upload/1238378097640_swf.swf"><PARAM NAME="WMode" VALUE="Window"><PARAM NAME="Play" VALUE="-1"><PARAM NAME="Loop" VALUE="-1"><PARAM NAME="Quality" VALUE="High"><PARAM NAME="SAlign" VALUE=""><PARAM NAME="Menu" VALUE="-1"><PARAM NAME="Base" VALUE=""><PARAM NAME="AllowScriptAccess" VALUE=""><PARAM NAME="Scale" VALUE="ShowAll"><PARAM NAME="DeviceFont" VALUE="0"><PARAM NAME="EmbedMovie" VALUE="0"><PARAM NAME="BGColor" VALUE=""><PARAM NAME="SWRemote" VALUE=""><PARAM NAME="MovieData" VALUE=""><PARAM NAME="SeamlessTabbing" VALUE="1"><PARAM NAME="Profile" VALUE="0"><PARAM NAME="ProfileAddress" VALUE=""><PARAM NAME="ProfilePort" VALUE="0"><PARAM NAME="AllowNetworking" VALUE="all"><PARAM NAME="AllowFullScreen" VALUE="false">
<embed src=../upload/1238378097640_swf.swf 
pluginspage=<A>'</A>http://www.macromedia.com/go/getflashplayer<A>'</A> 
type=<A>'</A>application/x-shockwave-flash<A>'</A>  width=100% height=100%></embed></OBJECT>)</STRONG><BR>&nbsp;&nbsp;&nbsp; 当链路状态发生变化时，OSPF通过洪泛过程通告网络上其它路由器。OSPF路由器接收到包含有新信息的链路状态更新报文，将更新自己的链路状态数据库，然后用SPF算法重新计算路由表。在重新计算过程中，路由器继续使用旧路由表，直到SPF完成新的路由表计算。新的链路状态信息将发送给其它路由器。<BR><STRONG>七. OSPF链路状态公告类型</STRONG><BR>&nbsp;&nbsp;&nbsp; OSPF路由器之间交换链路状态公告（LSA）信息。OSPF的LSA中包含连接的接口、使用的Metric及其它变量信息。OSPF路由器收集链接状态信息并使用SPF算法来计算到各节点的最短路径。LSA也有几种不同功能的报文，在这里简单地介绍一下：<BR>&nbsp;&nbsp;&nbsp; LSATYPE1：由每台路由器为所属的区域产生的LSA，描述本区域路由器链路到该区域的状态和代价。一个边界路由器可能产生多个LSATYPE1。<BR>&nbsp;&nbsp;&nbsp; LSATYPE2：由DR产生，含有连接某个区域路由器的所有链路状态和代价信息。只有DR可以监测该信息。<BR>&nbsp;&nbsp;&nbsp; LSATYPE3：由ABR（区域边界路由器）产生，含有ABR与本地内部路由器连接信息，可以描述本区域到主干区域的链路信息。它通常汇总缺省路由而不是传送汇总的OSPF信息给其它网络。<BR>&nbsp;&nbsp;&nbsp; LSATYPE4：由ABR产生，由主干区域发送到其它ABR，含有ASBR（自治系统边界路由器）的链路信息，与LSATYPE3的区别在于TYPE4描述到OSPF网络的外部路由，而TYPE3则描述区域内路由。<BR>&nbsp;&nbsp;&nbsp; LSATYPE5：由ASBR产生，含有关于自治域外的链路信息。除了存根区域和完全存根区域，LSATYPE5在整个网络中发送。<BR>&nbsp;&nbsp;&nbsp; LSATYPE6：MOSF（多播OSPF）可以让路由器利用链路状态数据库的信息构造用于多播报文的多播发布树。<BR>&nbsp;&nbsp;&nbsp; LSATYPE7：由ASBR产生的关于NSSA的信息。LSATYPE7可以转换为LSATYPE5。</td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 