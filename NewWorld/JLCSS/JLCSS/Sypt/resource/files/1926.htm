<html> <head> <meta http-equiv="Content-Type" content="text/html; charset=gb2312" /> <title></title> <link href="inc/style.css" rel="stylesheet" type="text/css"> </head>  <body class=infobody> <table width="100%" height="100%" cellspacing="0">  <tr>  <td valign="top"> <table>   <tr>   <td height=25></td>   </tr>           <table width="100%" border="0" align="center" cellpadding="0" cellspacing="0" style="border-bottom:#1873b5 solid 1px">             <tr><td style="background-image:url(images/cinfo_left.GIF);display:none" width="5"></td>               <td width="86" height="28" style="padding-left:4px;padding-right:4px;background-image:url(images/cinfo_center.GIF);color:#3081bd;text-align:center;padding-bottom:0px;padding-top:4px;display:none"><nobr>aabb1aabb</nobr></td> <td style="background-image:url(images/cinfo_right.GIF);display:none" width="5"></td>               <td>&nbsp;</td>             </tr>           </table>           <table width="100%" border="0" align="center" cellpadding="5" cellspacing="1" bgcolor="#FFFFFF" style="border:#1873b5 solid 1px;border-top:0px">             <tr>               <td bgcolor="#F5FAFA" style="padding-left:20;padding-right:20px" id="ptitle"><P>&nbsp;&nbsp;&nbsp; 客户和服务器都能够以并发方式运行。<BR>&nbsp;&nbsp;&nbsp; （1）客户中的并发<BR>&nbsp;&nbsp;&nbsp; 在一台主机上的客户程序可以循环或者并发地运行。循环运行的客户程序表示运行这些客户程序是一个接一个的；客户程序必须经过启动、运行和终止，然后这个主机才能再启动另一个客户程序。并发运行表示程序允许客户在同一时间运行两个或多个客户程序。<BR>&nbsp;&nbsp;&nbsp; （2）服务器中的并发<BR>&nbsp;&nbsp;&nbsp; 服务器程序也可以循环或者并发地运行。循环服务器一次只能处理一个请求，它接收一个请求，处理它，并向请求者发送响应，在此之后，它才能处理另一个请求。并发服务器可以在同一时刻处理多个请求，因而能够在多个请求之间共享服务器的时间。<BR>&nbsp;&nbsp;&nbsp; 服务器可以使用面向无连接的传输层协议UDP协议也可以使用面向连接的传输层协议TCP协议。因此，服务器运行取决于两个因素：传输层协议和服务方法。从理论上讲，可以有四种类型的服务器：无连接循环的、无连接并发的、面向连接循环的和面向连接并发的，但只有第一种和最后一种是常用的，如下图所示。</P>
<P align=center><IMG src="../upload/1234943168453_pic.gif"></P>
<P align=center>图5&nbsp; 服务器的类型</P>
<P>&nbsp;&nbsp;&nbsp; ●&nbsp; 面向无连接循环服务器：<BR>&nbsp;&nbsp;&nbsp; 使用UDP的服务器通常是循环的，服务器一次处理一个请求。服务器从UDP的数据报中得到请求，处理这个请求，把响应交给UDP发送给客户。UDP数据报存储在一个列队中等待服务。它们可以是来自一个客户，也可以是来自多个客户的。这些数据报按它们到达顺序一个接一个地被处理。<BR>&nbsp;&nbsp;&nbsp; 为此，服务器只使用一个熟知端口。所有到达这个端口的数据报都在队列中等待服务，如下图所示：</P>
<P align=center><IMG src="../upload/1234943184859_pic.gif"></P>
<P align=center>图6&nbsp; 无连接循环服务器</P>
<P>&nbsp;&nbsp;&nbsp; ●&nbsp; 面向连接并发服务器：<BR>&nbsp;&nbsp;&nbsp; 通常使用TCP的服务器都是并发的，服务器在同一时刻可对多个客户提供服务。通信是面向连接的，在服务器和每一个客户之间都要建立连接。而连接一直保持打开的，直到整个的字节流都处理完毕，然后连接就被终止了。<BR>&nbsp;&nbsp;&nbsp; 这种类型的服务器不能只使用一个熟知端口，因为每一个连接需要一个端口。服务器使用一个熟知端口和多个短暂端口。服务器在熟知端口进行被动打开。客户可以最初先在这个端口进行连接。在连接建立后，服务器就为这个连接指派一个临时端口以便空出这个熟知端口。客户就可以和这个临时端口建立连接。这种方法使得TCP能够很好的分用。<BR>&nbsp;&nbsp;&nbsp; 服务器还必须为每一个连接设置一个缓存。从客户端来的报文就存储在这个缓存中，然后服务器并发地处理这些缓存中的数据。<BR>&nbsp;&nbsp;&nbsp; 为了提供这种服务，大多数服务器使用父服务器和子服务器。父服务器是一个不停运行的、接受从客户发起连接的服务器，父服务器使用熟知端口。当父服务器接收了连接请求之后，它就使用一个子服务器和一个短暂端口，并让子服务器处理这个服务。它就使自己空闲出来，等待其它的连接。下图表示了这种面向连接并发服务器。</P>
<P align=center><IMG src="../upload/1234943202000_pic.gif"></P>
<P align=center>图7&nbsp; 面向连接并发服务器</P></td>             </tr>           </table>  </td> </tr> </table> </body> </html> <script> if(window.HTMLElement) {     HTMLElement.prototype.__defineSetter__("outerHTML",function(sHTML){         var r=this.ownerDocument.createRange();         r.setStartBefore(this);         var df=r.createContextualFragment(sHTML);         this.parentNode.replaceChild(df,this);         return sHTML;         });      HTMLElement.prototype.__defineGetter__("outerHTML",function(){      var attr;         var attrs=this.attributes;         var str="<"+this.tagName.toLowerCase();         for(var i=0;i<attrs.length;i++){             attr=attrs[i];             if(attr.specified)                 str+=" "+attr.name+'="'+attr.value+'"';             }         if(!this.canHaveChildren)             return str+">";         return str+">"+this.innerHTML+"</"+this.tagName.toLowerCase()+">";         });           HTMLElement.prototype.__defineGetter__("canHaveChildren",function(){   switch(this.tagName.toLowerCase()){             case "area":             case "base":          case "basefont":             case "col":             case "frame":             case "hr":             case "img":             case "br":             case "input":             case "isindex":             case "link":             case "meta":             case "param":             return false;         }         return true;       }); }  function showMe(i) {  	objHtml=document.all["s"+i].innerHTML; 	date=new Date(); 	if(navigator.userAgent.indexOf("MSIE")>0) 		window.status="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	else 		top.document.title="cmdOpen,"+date.getTime()+","+(objHtml.substring(objHtml.lastIndexOf("\"",objHtml.indexOf(".swf\""))+1,objHtml.indexOf(".swf\"")+4)); 	}  	if(navigator.userAgent.indexOf("MSIE")>0) 	var objects=document.all.tags("OBJECT"); 	else 	var objects=document.getElementsByTagName("OBJECT"); 	for(i=0;i<objects.length;i++) { objects[i].style.width="100%"; objects[i].outerHTML="<a href=# onclick=\"showMe("+i+")\">动画演示</a><span id=s"+i+" style=\"display:none\">"+objects[i].outerHTML+"</span>"; } var iHtml=document.body.innerHTML;  </script> 